title = "Lab Notebook 2024-06-09"
timestamp = "2024-06-09"
slug = "2024-06-09"
kind = "lab"
---

This is the first entry in my public lab notebook, where I intend to
document how I'm learning. I've had a private lab notebook for a few years
now, but reading [Casey Handmer's latest post][casey], I decided it would be
more beneficial to publish at least a semi-regular digest to the public.
These posts are set apart from the other, regular blog posts on this site,
and undergo much lighter editing to reduce the barrier for me to actually
write one of these. Careful readers might also observe that I'm using a
different style here than in the main posts, one that is much closer to my
everyday speech.

[casey]: https://caseyhandmer.wordpress.com/2024/06/08/how-to-learn-hardware/

# Origins

Given that this is the first entry, I need to provide some background for
what is happening here. Maybe two years ago or so, I came across Joe
Barnard's excellent YouTube channel [BPS.space][bps]. Joe is a model
rocketeer with a music degree and way too much ambition for his own good.
Everything he makes is incredible, go check it out.

Anyway, there was a video at some point where he talked about how he got
into this, and it went vaguely like:

> I saw SpaceX propulsively land a Falcon 9, and all of a sudden realized I
> had chosen the wrong career.

_Not an actual quote, me paraphrasing._

Given his music degree and subsequent student debt, he wasn't really in a
position to get an engineering degree, so he figured that if he could just
cram all the required knowledge by himself, he might be able to make it
anyway. From what I understand it sort of worked out, he [propulsively
landed a model rocket][scout], and supposedly has gotten job offers from
real aerospace companies, but decided to pursue YouTube for the time being.

I've been a software engineer for over a decade now, and like Joe I'm
entirely self-taught, which I think has given me a decent ability to
actually learn new skills after having left a guided education system. I've
mostly worked in web backends though, and while there are some interesting
challenges, I'm often seeing myself drawn to the physical world. Deploying
into a Kubernetes cluster just isn't quite the same as landing a rocket.

There might also be an element of feeling like I'm hitting the ceiling in my
field. I've worked on reasonably large projects such as Formula 1 TV and
CircleCI, and jobs that have similar levels of challenges are actually quite
rare, as larger projects usually come with larger teams as well.

So I've spent the last two years and change studying outside my direct field,
branching into embedded software and electronics. I've bought and worked
through a number of books:[^1]

- Electronics
    - Electronics Fundamentals, Floyd/Buchla
    - Electronic Devices, Floyd
    - The Art of Electronics, Horowitz/Hill
    - High Speed Digital Design, Johnson/Graham
- Control
    - Control Theory, Leigh
    - Feedback Systems, Astrom/Murray
    - Digital Signal Processing, Smith
- Engineering
    - Thinking in Systems, Meadowns
    - Structures, Gordon
    - Ignition, Clark
    - Sidewinder, Westrum
    - The Planet Remade, Morton
    - Stuff Matters, Miodownik
    - What Made Apollo a Success?, NASA
    - The Art of Doing Science and Engineering, Hamming
- Firmware
    - Programming Rust, Blandy
    - Rust Atomics and Locks, Bos
    - NASA Software Safety Guidebook

From my selection you can see that I've been learning fundamentals in
electronics and mechanical engineering, with a bias towards control systems
and of course aerospace, but also looking at green tech, which is close to
my heart personally.

I've also learnt how to use a variety of software and hardware, I have
probed circuit boards designed in KiCAD with an oscilloscope, and 3D-printed
mechanical parts designed in Fusion 360 or OnShape. I've even tuned PID
controllers in Simulink.

I'm not entirely sure where this will get me, if anywhere, but I believe
that generalists are often more useful than specialists, and incidentally it
is also much easier to become a generalist if you know how to learn new
things. Some of my newly acquired embedded programming techniques have already
found their way back into my day job.

Now of course none of this is worth much in isolation. I just finished
reading _The Art of Doing Science and Engineering_ yesterday, and it's
mostly an inspirational book. Hamming argues a few things, but he has a few
core points I want to talk about:

1. It's better to (try to) achieve something worthwhile than just living day
   to day.
2. Examine the bigger picture to find out where the current frontier is in a
   field. That's where you should be working.
3. Often experts from other fields can provide a necessary new perspective
   to advance that frontier.
4. Science and engineering are a group effort, you cannot work in isolation.

The last point is why we're here. I've often toyed with the idea of making
my own YouTube channel to document my progress, but that is a lot of work
that I don't necessarily enjoy. Writing on the other hand presents a much
lower bar to me, so that is the medium I chose.

I also have some thoughts about the middle two points: I have pretty deep
experience in software design and architecture, especially developer tooling,
as well as some background in compilers. Seeing the current state of
embedded software, I do believe there are some things that industry can
learn from the much more rapidly evolving web industry. And that is exactly
the overlap where I hope I can be useful.

One of the major concrete points I'm looking at is the adoption of Rust.
I've been writing Rust for a couple of years now, in fact, this very website
is written in it. Embedded systems are one of the most promising areas where
Rust is bound to be adopted, both for increased safety and vastly improved
developer experience. That adoption has been slow, but it seems to be
reaching the steep section of the adoption curve just now, and I want in on
that.

And if I'm lucky, I'll find myself building something one day that I can
point at.

[bps]: https://www.youtube.com/@BPSspace

[scout]: https://www.youtube.com/watch?v=SH3lR2GLgT0

[^1]: Given the overlap of some books here, I consider Horowitz/Hill the
best book on electronics I've read, and Feedback systems easier to digest
than Control Theory.

# The Actual Entry

I briefly toyed with the idea of constructing a dongle that would
connect to a keyboard and power it, relaying the inputs via Bluetooth to a
computer, converting a wired keyboard into a wireless one. I spent two
evenings picking out a draft BOM, but ultimately came to the conclusion that
the expected battery life would be less than eight hours with what I
considered reasonably physical dimensions. The main problem there actually
being the keyboard itself, my keyboard currently drawing 120 mW. I was
hoping for something small enough that it can physically hang off the USB-C
connection, which means a LiPo battery in the realm of 1 Wh.

My current project is a hopper with thrust-vector control, somewhat like Joe
Barnad's Sprite. He used an EDF, a ducted fan, whereas I'm using a motor
plus rotor setup meant for quadcopters. The main challenges here arise in
the available thrust, as well as the required diameter of the vehicle as a
whole.

I've designed and printed a smaller, toroidal propeller, but that produced
much less thrust, probably also because propellers are difficult to design,
and I did not consult any guidance on that. Worse, during a max-thrust test
run, the propeller exploded on me. That's why I'm always wearing safety
glasses when I go into engineering mode.

I have commercial quadcopter propellers, and I guess I'll go with those for
the time being. The resulting vehicle will be somewhat heavy, so I don't
know if I'll have enough thrust available for a gentle hover. It's designed
in a modular way though, so that I can add additional coaxial propellers,
which might be nice anyway to cancel out any z-axis torque.

I've already designed and printed the actual TVC setup, with thrust vanes
mounted on small 9g servo motors, and those work great.

Of course, I'm writing the firmware in Rust, and this is actually my second
Rust firmware. The first one, for a different project, ran on the SAMD21G, and
was written entirely from scratch. For this project I've chosen to use the
STM32F4, which is a much more widely used chip in the industry, and thus
more useful to me to learn about. The new firmware is also making use of
[embassy](https://github.com/embassy-rs/embassy), which I believe has a
future in the embedded world.

This should make it clear that the hopper project is not meant to be useful,
except for learning about tools and building practical experience.

One of the avenues I'm exploring is a software-in-the-loop setup for Rust that
allows me to replace actual hardware with simulated versions when running the
code on the computer, which could be used to even connect the firmware up to
e.g. Matlab without even needing to run it on the real hardware. Being able to
run some amount of unit tests directly on the developer machine is also much
more convenient. I had this feature in the first iteration of the firmware, but
have not ported it in a generalized fashion yet. I hope that this is something I
can publish at some point, to advance the field.

Anyway, I have some rough bits of firmware that can control individual
components like DC motors and servos, the next step is probably printing the
remainder of the construction and run a thrust test to see if I can hover on
a single rotor, so that is what I'm going to do next.

I'm also thinking of brushing up on my calculus by reading Quick Calculus next.
