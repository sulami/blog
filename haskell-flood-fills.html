<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Haskell Flood Fills</title>
    <link rel="icon" href="https://sulami.github.io/favicon.ico" />
    <link rel="stylesheet" href="https://sulami.github.io/theme/css/main.css" />
    <link href="https://sulami.github.io/feed/rss.xml" type="application/rss+xml" rel="alternate" title="/dev/sulami >> blog RSS Feed" />

    <!--[if IE]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body id="index" class="home">
    <header id="banner" class="body">
            <nav>
            <a href="https://sulami.github.io/">/dev/sulami >> blog</a> |
                <a href="https://sulami.github.io/pages/about-me.html">About me</a>
                <a href="https://sulami.github.io/category/coding.html">Coding</a>
                <a href="https://sulami.github.io/category/hardware.html">Hardware</a>
                <a href="https://sulami.github.io/category/linux.html">Linux</a>
                <a href="https://sulami.github.io/category/web.html">Web</a>
            <a href="https://sulami.github.io/feed/rss.xml">RSS</a>
            </nav>
    </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        >>
        <a href="https://sulami.github.io/haskell-flood-fills.html" rel="bookmark"
           title="Permalink to Haskell Flood Fills">Haskell Flood Fills</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
    <span class="date">2015-07-21</span>
    |
    in <a href="https://sulami.github.io/category/coding.html">Coding</a>
</footer><!-- /.post-info -->
      <p>Over the past two days, I played a bit with the <a href="https://hackthe.computer/">hackthe.computer
contest</a>. It is a contest with a couple of problems/tasks where you have
one week to write up the best solutions in terms of speed. Part of the
difficulty comes from the fact, that you push git commits to their server and
do not get to to see the output of their test runs, which you only know if you
program produces the correct output within a reasonable time frame (one minute
per test?) or not. It is quite fun, also because the problems are nicely
chosen, with a lot of data interpretation, but also a need for efficient
algorithms, and they all have nice back stories to explain why we are dealing
with seemingly random input.</p>
<p>The first problem is called <em>Bowie's in a maze</em>, which, without spoiling too
much, involves David Bowie and a maze. Bowie is actually the villain here. To
save our little brother, we have to find him in his maze. To accomplish this,
we get an ASCII-map of the maze with our position and the position of our
brother. The specific task is to find the shortest route in the least amount of
time possible.</p>
<p>The naive first attempt was finding the shortest of all possible paths, but
several of their test cases include really large mazes with few walls, if any
at all (remember, I do not know). So this ran forever. From there, my mind
obviously went to flood fills quite fast, because we save a lot of time, both
by not building tons of overlapping paths, and, because a queue-based flood
fill will return the shortest possible correct path before any longer
solutions, using a lazy list of routes we can stop evaluating paths after the
first one that reaches our brother.</p>
<p>I have written flood fills before, but mostly in Python, where the approach is
quite a bit different. And because I could not really find a nice example of
how to do flood fills in Haskell, I will post a general example here, just for
you, fellow coder. So, here we go:</p>
<div class="codehilite"><pre><span class="c1">-- First, we define a couple of types, for better readability. The grid</span>
<span class="c1">-- will be a line-wise list of strings, with every char being a cell.</span>
<span class="kr">type</span> <span class="kt">Grid</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="kr">type</span> <span class="kt">Coord</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Path</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Coord</span><span class="p">]</span>

<span class="c1">-- So, we flood fill. This list can be lazily evaluated from the head and</span>
<span class="c1">-- returns branching paths in all directions that obey possibleWays and do</span>
<span class="c1">-- not overlap. flood is actually just a wrapper for fl.</span>
<span class="nf">flood</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Coord</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Path</span><span class="p">]</span>
<span class="nf">flood</span> <span class="n">grid</span> <span class="n">pos</span> <span class="ow">=</span> <span class="n">fl</span> <span class="n">grid</span> <span class="p">[[</span><span class="n">pos</span><span class="p">]]</span>
  <span class="kr">where</span>
    <span class="c1">-- This might be a bit difficult to grasp, but this returns all paths</span>
    <span class="c1">-- ever evaluated and appends a copy of every path already evaluated</span>
    <span class="c1">-- that could continue somewhere for a single step without overlapping</span>
    <span class="c1">-- with any other path.</span>
    <span class="n">fl</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Path</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Path</span><span class="p">]</span>
    <span class="n">fl</span> <span class="n">grid</span> <span class="n">paths</span> <span class="ow">=</span> <span class="n">paths</span> <span class="o">++</span> <span class="n">fl</span> <span class="n">grid</span> <span class="p">(</span><span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">addRoutes</span> <span class="n">grid</span> <span class="n">paths</span><span class="p">)</span> <span class="n">paths</span><span class="p">)</span>

    <span class="c1">-- This handles the replacing of a path with all its possible branches.</span>
    <span class="c1">-- It also has the context of all the other paths to prevent</span>
    <span class="c1">-- overlapping.</span>
    <span class="n">addRoutes</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Path</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Path</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Path</span><span class="p">]</span>
    <span class="n">addRoutes</span> <span class="n">grid</span> <span class="n">ps</span> <span class="n">path</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">path</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">|</span> <span class="n">p</span> <span class="ow">&lt;-</span> <span class="n">possibleWays</span> <span class="n">grid</span> <span class="o">$</span> <span class="n">last</span> <span class="n">path</span><span class="p">,</span>
                                             <span class="n">not</span> <span class="o">$</span> <span class="n">p</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">(</span><span class="n">concat</span> <span class="n">ps</span><span class="p">)</span> <span class="p">]</span>

    <span class="c1">-- All this does is, from a given point on the grid, look where we</span>
    <span class="c1">-- could go while obeying the rules of the game, like not leaving the</span>
    <span class="c1">-- grid (Index error!), only going one step (maybe diagonally?), etc.</span>
    <span class="c1">-- The actual code depends on what you want to do, but a list</span>
    <span class="c1">-- comprehension works well here, using the surrounding coordinates as</span>
    <span class="c1">-- inputs and filtering out the invalid ones.</span>
    <span class="n">possibleWays</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Coord</span> <span class="ow">-&gt;</span> <span class="kt">Path</span>
    <span class="n">possibleWays</span> <span class="n">g</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">)</span> <span class="o">|</span> <span class="o">..</span> <span class="p">]</span>

<span class="c1">-- This is a simple little helper that checks if the last cell of a path is</span>
<span class="c1">-- the target, so we can filter out incomplete paths.</span>
<span class="nf">reachesTarget</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Path</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">reachesTarget</span> <span class="n">g</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last</span> <span class="n">p</span> <span class="kr">in</span> <span class="n">g</span> <span class="o">!!</span> <span class="n">y</span> <span class="o">!!</span> <span class="n">x</span> <span class="o">==</span> <span class="sc">&#39;F&#39;</span>

<span class="c1">-- This a a really basic example use of the functions above.</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">grid</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="n">lines</span> <span class="n">getContents</span>          <span class="c1">-- Read a map from stdin.</span>
          <span class="kr">let</span> <span class="n">start</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>      <span class="c1">-- Start filling from the top-left corner.</span>
          <span class="c1">-- My example involves finding the length of shortest possible</span>
          <span class="c1">-- route, so we start flood filling lazily, and take the first</span>
          <span class="c1">-- complete path. Then we just print out its length, because</span>
          <span class="c1">-- paths themselves do not print nicely without a pretty printer.</span>
          <span class="kr">let</span> <span class="n">path</span> <span class="ow">=</span> <span class="n">head</span> <span class="o">$</span> <span class="n">filter</span> <span class="p">(</span><span class="n">reachesTarget</span> <span class="n">grid</span><span class="p">)</span> <span class="o">$</span> <span class="n">flood</span> <span class="n">grid</span> <span class="n">start</span>
          <span class="n">print</span> <span class="o">$</span> <span class="n">length</span> <span class="n">path</span>
</pre></div>


<p>You can use this code pretty much like this (I hereby license it under ISC), by
just filling in <code>possibleWays</code>. Note that this can get a bit slow when the grid
is large and contains few or no walls, because the list of paths to iterate
over grows rather large. You can probably gain some additional performance by
introducing parallelism via <code>par</code> and <code>pseq</code> if that becomes a problem.</p>
    </div><!-- /.entry-content -->
  </article>
</section>
</body>
</html>
