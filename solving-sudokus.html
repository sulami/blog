<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Solving Sudokus</title>
    <link rel="icon" href="https://sulami.github.io/favicon.ico" />
    <link rel="stylesheet" href="https://sulami.github.io/theme/css/main.css" />
    <link href="https://sulami.github.io/feed/rss.xml" type="application/rss+xml" rel="alternate" title="/dev/sulami >> blog RSS Feed" />

    <!--[if IE]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body id="index" class="home">
    <header id="banner" class="body">
        <nav>
          <div id="menu">
            <a href="https://sulami.github.io/">/dev/sulami >> blog</a> |
            <a href="https://sulami.github.io/feed/rss.xml">RSS</a>
          </div>
        </nav>
    </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        >>
        <a href="https://sulami.github.io/solving-sudokus.html" rel="bookmark"
           title="Permalink to Solving Sudokus">Solving&nbsp;Sudokus</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
    <span class="date">2015-07-06</span>
    <!-- | -->
    <!-- in <a href="https://sulami.github.io/category/misc.html">misc</a> -->
</footer><!-- /.post-info -->
      <p>So, here is more Haskell from me, because I really like it. This time around, I
wrote a small and simple sudoku solver. Sudokus are really nice little puzzles
that involve a partially filled 9x9 grid containing numbers from one to nine.
The objective is to fill it following these&nbsp;rules:</p>
<ul>
<li>Each number must only appear once per&nbsp;row</li>
<li>Each number must only appear once per&nbsp;column</li>
<li>Each number must only appear once per 3x3 &#8216;box&#8217;, of which there are&nbsp;nine</li>
</ul>
<p>A common strategy is checking empty cells for available numbers to fill in, so
the ones that are not already present in the corresponding row, column or box.
This is also the approach my solver takes, by checking each of the empty cells
for options and, if there is only one possible option, filling it in. Repeat
this until there are no empty cells anymore and you have a guaranteed correct
solution. There is a great deal of mathematics behind sudoku puzzles, and if
you are interested in that, <a href="https://en.wikipedia.org/wiki/Mathematics_of_Sudoku">the Wikipedia article</a> is a great&nbsp;read.</p>
<p>Because I wrote my solver before conducting any research, it emulates my
approach, which is brute forcing. Still, it solves 9x9 sudokus in &lt;0.01
seconds. We will now have an in-depth look at it. If you want context, the
whole code including an example is on <a href="https://github.com/sulami/spielwiese/blob/master/hSudoku/">Github</a>.</p>
<p>I implemented the solver in form of a Haskell library that exports three&nbsp;functions:</p>
<ul>
<li><code>build</code> builds the internal representation of the puzzle from a list of&nbsp;integers</li>
<li><code>prettyPrint</code> prints a&nbsp;puzzle</li>
<li><code>solve</code> solves a&nbsp;puzzle</li>
</ul>
<p><code>build</code> is really simple, because it looks like&nbsp;this:</p>
<div class="codehilite"><pre><span></span><span class="nf">build</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Grid</span>
<span class="nf">build</span> <span class="n">vs</span> <span class="ow">=</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="n">vs</span>
</pre></div>


<p>This already exposes the internal structure of a puzzle, which is&nbsp;this:</p>
<div class="codehilite"><pre><span></span><span class="kr">type</span> <span class="kt">Value</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Coord</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Cell</span>  <span class="ow">=</span> <span class="p">(</span><span class="kt">Coord</span><span class="p">,</span> <span class="kt">Value</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Grid</span>  <span class="ow">=</span> <span class="p">[</span><span class="kt">Cell</span><span class="p">]</span>
</pre></div>


<p>I chose to use a single associative list over a nested list because it makes
the code a whole lot easier to read when accessing various cells of a grid, at
the expense of having to do some&nbsp;maths.</p>
<p><code>prettyPrint</code> is not really worth explaining or even showing, all it does is
dividing a grid into nine chunks, the lines, converting the integers to chars,
replacing zeros with underscores, insert some spaces for readability and prints
the whole thing out. I just added it so I could check the results&nbsp;easily.</p>
<p><code>solve</code> is the really interesting part here. Solve loops until a puzzle is
solved, which looks like&nbsp;this:</p>
<div class="codehilite"><pre><span></span><span class="nf">solved</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">solved</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kt">False</span> <span class="kr">else</span> <span class="n">r</span><span class="p">)</span> <span class="kt">True</span>

<span class="nf">solve</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Grid</span>
<span class="nf">solve</span> <span class="n">g</span> <span class="o">|</span> <span class="n">solved</span> <span class="n">g</span>  <span class="ow">=</span> <span class="n">g</span>
        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">solve</span> <span class="o">$</span> <span class="n">fill</span> <span class="n">g</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">get</span> <span class="n">g</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>What <code>fill</code> does is it iterates once through all the cells, and each time it
encounters an empty cell (<code>(_, 0)</code>), it checks which numbers could be placed in
it. If there is only one possibility, it changes the grid accordingly and
continues. After a complete iteration, it returns the changed&nbsp;grid.</p>
<div class="codehilite"><pre><span></span><span class="nf">fill</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Cell</span> <span class="ow">-&gt;</span> <span class="kt">Grid</span>
<span class="nf">fill</span> <span class="n">g</span> <span class="n">c</span><span class="o">@</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">81</span>          <span class="ow">=</span> <span class="n">g</span>
                <span class="o">|</span> <span class="n">v</span> <span class="o">/=</span> <span class="mi">0</span>           <span class="ow">=</span> <span class="n">fill</span> <span class="n">g</span> <span class="n">next</span>
                <span class="o">|</span> <span class="n">length</span> <span class="n">opts</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">=</span> <span class="n">fill</span> <span class="p">(</span><span class="n">change</span> <span class="n">g</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">head</span> <span class="n">opts</span><span class="p">)))</span> <span class="n">next</span>
                <span class="o">|</span> <span class="n">otherwise</span>        <span class="ow">=</span> <span class="n">fill</span> <span class="n">g</span> <span class="n">next</span>
  <span class="kr">where</span>
    <span class="n">next</span> <span class="ow">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">get</span> <span class="n">g</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">opts</span> <span class="ow">=</span> <span class="n">options</span> <span class="n">g</span> <span class="n">c</span>
</pre></div>


<p><code>change</code> goes through the grid, looking for the cell we want to change,
replaces the value and returns the changed grid, so we can use it for the
remainder of the iteration. It is very easily implemented using a single <code>map</code>:</p>
<div class="codehilite"><pre><span></span><span class="nf">change</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Cell</span> <span class="ow">-&gt;</span> <span class="kt">Grid</span>
<span class="nf">change</span> <span class="n">g</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">gn</span><span class="p">,</span> <span class="n">gv</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">gn</span> <span class="o">==</span> <span class="n">n</span> <span class="kr">then</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="n">gn</span><span class="p">,</span> <span class="n">gv</span><span class="p">))</span> <span class="n">g</span>
</pre></div>


<p><code>get</code> gets the value of the cell at a coordinate in a grid, pretty&nbsp;simple:</p>
<div class="codehilite"><pre><span></span><span class="nf">get</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Coord</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
<span class="nf">get</span> <span class="n">g</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">$</span> <span class="n">g</span> <span class="o">!!</span> <span class="n">n</span>
</pre></div>


<p><code>options</code> on the other hand is a little bit more complicated. It has to check
the row, the column and the box a given cell is in, and check for a number
between one and nine that is not already present in any of them. And because I
chose to use a single list to represent the whole grid, having the list indices
stored inside a cell comes in very handy, because we can use it to calculate
the indices of the other cells in the same row, column and box. But first, this
is <code>options</code>:</p>
<div class="codehilite"><pre><span></span><span class="nf">options</span> <span class="ow">::</span> <span class="kt">Grid</span> <span class="ow">-&gt;</span> <span class="kt">Cell</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
<span class="nf">options</span> <span class="n">g</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="p">(</span><span class="n">rowWise</span> <span class="n">n</span><span class="p">)</span> <span class="o">++</span> <span class="p">(</span><span class="n">colWise</span> <span class="n">n</span><span class="p">)</span> <span class="o">++</span> <span class="p">(</span><span class="n">boxWise</span> <span class="n">n</span><span class="p">)</span> <span class="kr">in</span>
                    <span class="n">filter</span> <span class="p">(`</span><span class="n">notElem</span><span class="p">`</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">get</span> <span class="n">g</span><span class="p">)</span> <span class="n">r</span><span class="p">))</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">9</span><span class="p">]</span>
</pre></div>


<p>It looks a bit overloaded, but is actually quite easy. <code>r</code> is a composite list
that includes all the coordinates (/indices) of the cells that affect the
possible content of this cell. We <code>map</code> it to get to transform it to a list of
numbers that are not possible here, and then simply return all numbers between
one and nine that are not in that list. If you go back to <code>fill</code> above, you can
see that if the length of this list is one, this solution is filled&nbsp;in.</p>
<p>To finish this off, here are the three remaining functions that calculate the
coordinates of the affecting cells. I planned these out when I could not sleep&nbsp;yesterday.</p>
<div class="codehilite"><pre><span></span><span class="nf">rowWise</span> <span class="ow">::</span> <span class="kt">Coord</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Coord</span><span class="p">]</span>
<span class="nf">rowWise</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">n</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">9</span> <span class="o">*</span> <span class="mi">9</span> <span class="kr">in</span> <span class="p">[</span><span class="n">r</span><span class="o">..</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">8</span><span class="p">)]</span>

<span class="nf">colWise</span> <span class="ow">::</span> <span class="kt">Coord</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Coord</span><span class="p">]</span>
<span class="nf">colWise</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">os</span> <span class="ow">=</span> <span class="n">n</span><span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">9</span> <span class="kr">in</span> <span class="p">[</span><span class="n">os</span><span class="p">,(</span><span class="n">os</span><span class="o">+</span><span class="mi">9</span><span class="p">)</span><span class="o">..</span><span class="mi">80</span><span class="p">]</span>

<span class="nf">boxWise</span> <span class="ow">::</span> <span class="kt">Coord</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Coord</span><span class="p">]</span>
<span class="nf">boxWise</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">9</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">3</span>
                <span class="n">r</span> <span class="ow">=</span> <span class="n">n</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">27</span> <span class="o">*</span> <span class="mi">3</span>
                <span class="n">s</span> <span class="ow">=</span> <span class="n">r</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">3</span>
             <span class="kr">in</span> <span class="p">[</span><span class="n">s</span><span class="o">..</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">)]</span> <span class="o">++</span> <span class="p">[(</span><span class="n">s</span><span class="o">+</span><span class="mi">9</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">11</span><span class="p">)]</span> <span class="o">++</span> <span class="p">[(</span><span class="n">s</span><span class="o">+</span><span class="mi">18</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">20</span><span class="p">)]</span>
</pre></div>


<p><code>rowWise</code> and <code>colWise</code> should be pretty easy to understand if you imagine a
grid and try out some example cells. <code>boxWise</code> is a bit more contrived, what it
generally does it figures out in which of the nine boxes the cell is by
comparing the offset from the left and the offset from the top separately, and
then using the top-left cell of this box as a starting point to get the other
eight coordinates, which are always in the same relative&nbsp;position.</p>
<p>So this is the complete code to solve a sudoku puzzle. If you exclude the
printing stuff, it is about 50 lines long, and there is a lot to optimize here,
but I will leave it as it is, because I am only interested in the&nbsp;PoC.</p>
    </div><!-- /.entry-content -->
  </article>
</section>
</body>
</html>
