<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>A fuzzy finder in Haskell</title>
    <link rel="icon" href="https://sulami.github.io/favicon.ico" />
    <link rel="stylesheet" href="https://sulami.github.io/theme/css/main.css" />
    <link href="https://sulami.github.io/feed/rss.xml" type="application/rss+xml" rel="alternate" title="/dev/sulami >> blog RSS Feed" />

    <!--[if IE]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body id="index" class="home">
    <header id="banner" class="body">
            <nav>
            <a href="https://sulami.github.io/">/dev/sulami >> blog</a> |
                <a href="https://sulami.github.io/pages/about-me.html">About me</a>
                <a href="https://sulami.github.io/category/coding.html">Coding</a>
                <a href="https://sulami.github.io/category/hardware.html">Hardware</a>
                <a href="https://sulami.github.io/category/linux.html">Linux</a>
                <a href="https://sulami.github.io/category/web.html">Web</a>
            <a href="https://sulami.github.io/feed/rss.xml">RSS</a>
            </nav>
    </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        >>
        <a href="https://sulami.github.io/a-fuzzy-finder-in-haskell.html" rel="bookmark"
           title="Permalink to A fuzzy finder in Haskell">A fuzzy finder in Haskell</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
    <span class="date">2015-06-24</span>
    |
    in <a href="https://sulami.github.io/category/coding.html">Coding</a>
</footer><!-- /.post-info -->
      <p>This is a response to <em><a href="http://blog.amjith.com/fuzzyfinder-in-10-lines-of-python">FuzzyFinder - in 10 lines of Python</a></em>, which was
posted to reddit yesterday.</p>
<hr />
<p>Following the blogpost linked above, I decided to write my own fuzzy finder in
Haskell, because that is the language I am currently learning, and think has
great potential. It is also a more interesting <a href="https://github.com/sulami/spielwiese/tree/master/hEuler">exercise</a> than <a href="https://projecteuler.net/">Project
Euler</a>.</p>
<p>Just in case you have not read the original post and do not know what a fuzzy
finder is, it is a mechanism to filter and sort a list of strings by searching
for substrings. It is often used in text editors like vim or Sublime Text,
where you can just type in <em>"accmanba"</em> and they will open up
<code>account_management_backend.py</code> for you. As you can see, it makes switching
between more than two files in a project much easier and faster.</p>
<p>Amjith wrote his finder using regular expressions, which are part of the Python
standard library and can be compiled to be reasonably fast very easily. Sadly,
Haskell has no implementation of regular expressions in its standard library,
and I did not want to use third-party ones just for this. But as it turns out,
we do not even need them, because the task is so simple and Haskell's string
manipulation capabilities are incredible, so that we can solve this by
implementing the search algorithm ourselves and still achieve good performance.</p>
<p>So, let us get on to some actual code. The most interesting part here is the
matching algorithm:</p>
<div class="codehilite"><pre><span class="nf">partOf</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="nf">partOf</span> <span class="kr">_</span> <span class="kt">[]</span>     <span class="n">r</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nf">partOf</span> <span class="n">c</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">r</span> <span class="o">|</span>    <span class="n">c</span> <span class="o">==</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">partOf</span> <span class="n">c</span> <span class="n">xs</span> <span class="o">$</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>

<span class="nf">match</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">([</span><span class="kt">Char</span><span class="p">],</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span>
<span class="nf">match</span> <span class="n">i</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">match&#39;</span> <span class="n">i</span> <span class="p">(</span><span class="n">snd</span> <span class="n">s</span><span class="p">)</span> <span class="kt">[]</span>
  <span class="kr">where</span>
    <span class="n">match&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span>
    <span class="n">match&#39;</span> <span class="kt">[]</span>     <span class="kr">_</span> <span class="n">r</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">match&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">s</span> <span class="n">r</span> <span class="o">|</span> <span class="n">fst</span> <span class="n">check</span> <span class="ow">=</span> <span class="n">match&#39;</span> <span class="n">xs</span> <span class="p">(</span><span class="n">drop</span> <span class="n">used</span> <span class="n">s</span><span class="p">)</span> <span class="o">$</span> <span class="n">r</span> <span class="o">++</span> <span class="p">[</span><span class="n">used</span><span class="p">]</span>
                      <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
      <span class="kr">where</span>
        <span class="n">used</span> <span class="ow">=</span> <span class="n">snd</span> <span class="n">check</span>
        <span class="n">check</span> <span class="ow">=</span> <span class="n">partOf</span> <span class="n">x</span> <span class="n">s</span> <span class="mi">0</span>
</pre></div>


<p>I know this is not really optimized for readability and especially not if you
do not know Haskell, but stay with me, it is quite simple. Before we compare
the input, we map all the possible solutions to lowercase and store them in a
tuple like <code>("String", "string")</code>. This way, we can compare against the
lowercase version and return the properly capitalized one later on. All we do
then is check for each possible solution if each character of the input string
appears in order in the solution. If so, we add it to a list along with some
data, specifically the position of the first match and the distance between the
first and last matched character in the solution. This is the same Amjith did
for sorting. All this data gets returned in a big list of tuples with both
versions of the solutions and the match data. It is not pretty, but it works.</p>
<p>The one function the module actually exports is <code>fuzzyFinder</code>:</p>
<div class="codehilite"><pre><span class="nf">fuzzyFinder</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span>
<span class="nf">fuzzyFinder</span> <span class="n">input</span> <span class="n">list</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">map</span> <span class="n">snd</span> <span class="o">$</span> <span class="n">sort</span> <span class="n">combo</span>
  <span class="kr">where</span>
    <span class="n">combo</span> <span class="ow">=</span> <span class="n">zip</span> <span class="p">(</span><span class="n">zip</span> <span class="p">((</span><span class="n">map</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="n">tail</span><span class="p">)</span> <span class="n">scores</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">head</span> <span class="n">scores</span><span class="p">))</span> <span class="n">matches</span>
    <span class="n">scores</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">snd</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="n">match</span> <span class="n">input</span><span class="p">)</span> <span class="n">matches</span>
    <span class="n">matches</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="n">fst</span> <span class="o">.</span> <span class="n">match</span> <span class="n">input</span><span class="p">)</span> <span class="o">$</span> <span class="n">prepInput</span> <span class="n">list</span>
</pre></div>


<p>All this function does is build the tuple list with the lowercase versions,
toss it into the match function and filter out the correct versions from the
matches that came back, ordering them by the match data in the same way Amjith
did it. There are just a couple of extra lines that I omitted here because they
are not important, but you can find the complete source on <a href="https://github.com/sulami/spielwiese/tree/master/hFuzzyFinder">Github</a>.</p>
<p>Now you might say, this cannot be fast, it is iterating through all this stuff
and with big enough input it will take forever to present results. Let me show
you this:</p>
<div class="codehilite"><pre><span class="nf">readL</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">readL</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">read</span> <span class="o">$</span> <span class="s">&quot;[&quot;</span> <span class="o">++</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot;]&quot;</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">args</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
          <span class="kr">if</span> <span class="n">length</span> <span class="n">args</span> <span class="o">==</span> <span class="mi">2</span> <span class="kr">then</span> <span class="kr">do</span>
            <span class="n">list</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="o">$</span> <span class="n">args</span> <span class="o">!!</span> <span class="mi">1</span>
            <span class="n">print</span> <span class="o">$</span> <span class="n">fuzzyFinder</span> <span class="p">(</span><span class="n">args</span> <span class="o">!!</span> <span class="mi">0</span><span class="p">)</span> <span class="o">$</span> <span class="n">readL</span> <span class="n">list</span>
          <span class="kr">else</span>
            <span class="n">putStrLn</span> <span class="s">&quot;Wrong number of args&quot;</span>
</pre></div>


<p>This is a small program that takes two arguments, the query string and a file
path of a list of possible solutions and performs the actions outlined above.
Using a 2.2GHz Core 2 Duo, because I am using my laptop, and a 46K list
containing over 5000 words (Thanks, Project Euler), this happens:</p>
<div class="codehilite"><pre>λ time ./interactive roro ../hEuler/022.input
[&quot;ROBERTO&quot;,&quot;RODRIGO&quot;,&quot;ROSARIO&quot;,&quot;GREGORIO&quot;,&quot;RIGOBERTO&quot;]
./interactive roro ../hEuler/022.input  0.08s user 0.00s system 96% cpu 0.079 total
</pre></div>


<p>The execution time goes up to 0.09 seconds when printing out really many names,
but that is caused by the fact that we have to print out 100 lines or more to
the console, which also takes time. But in my opinion, this is more than fast
enough for auto-completion, which is the main use for fuzzy finders.</p>
<p>So overall, I am really happy with how this turned out. I was able to write
this on one morning despite still learning the language. It is reasonably
concise despite the fact that I did not use regular expressions but searched
the strings manually and also quite fast.</p>
    </div><!-- /.entry-content -->
  </article>
</section>
</body>
</html>
