<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Concurrent I/O in Haskell</title>
    <link rel="icon" href="https://sulami.github.io/favicon.ico" />
    <link rel="stylesheet" href="https://sulami.github.io/theme/css/main.css" />
    <link href="https://sulami.github.io/feed/rss.xml" type="application/rss+xml" rel="alternate" title="/dev/sulami >> blog RSS Feed" />

    <!--[if IE]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body id="index" class="home">
    <header id="banner" class="body">
        <nav>
          <div id="menu">
            <a href="https://sulami.github.io/">/dev/sulami >> blog</a> |
                <a href="https://sulami.github.io/pages/about-me.html">About&nbsp;me</a>
                <a href="https://sulami.github.io/pages/projects.html">Projects</a>
            <a href="https://sulami.github.io/feed/rss.xml">RSS</a>
          </div>
        </nav>
    </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        >>
        <a href="https://sulami.github.io/concurrent-io-in-haskell.html" rel="bookmark"
           title="Permalink to Concurrent I/O in Haskell">Concurrent I/O in&nbsp;Haskell</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
    <span class="date">2015-09-11</span>
    <!-- | -->
    <!-- in <a href="https://sulami.github.io/category/misc.html">misc</a> -->
</footer><!-- /.post-info -->
      <p>Today just after waking up, I have been tweaking the last bits and bops of
<a href="https://github.com/sulami/tinfoilsub">TinfoilSub</a>, a satiric fun/learning
project of mine that scrapes YouTube channels to replicate a subscriptions page
without requiring a Google account. The core of this little program is the
<code>runServer</code> function that uses
<a href="https://hackage.haskell.org/package/scotty">Scotty</a> to host a local page that
displays the results, while the list of channels is read from a file. In the
beginning, this function looked something like&nbsp;this:</p>
<div class="codehilite"><pre><span class="nf">runServer</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runServer</span> <span class="n">channels</span> <span class="ow">=</span> <span class="n">scotty</span> <span class="mi">3000</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">get</span> <span class="s">&quot;/&quot;</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">videos</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">sort</span> <span class="o">.</span> <span class="n">concatMaybe</span><span class="p">)</span> <span class="o">.</span> <span class="n">liftIO</span> <span class="o">.</span> <span class="n">sequence</span> <span class="o">$</span>
                <span class="n">map</span> <span class="n">scrapeChannel</span> <span class="n">channels</span>
    <span class="n">html</span> <span class="o">.</span> <span class="n">renderVideos</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">50</span> <span class="n">videos</span>
  <span class="c1">-- ... and more routes</span>
</pre></div>


<p>Now, imagine you have more than just a couple of channels in there. This works
fine for 2-3 channels, but each channel adds about a second of runtime each
time the page is refreshed and the channels are re-scraped, which quickly
amounts to way to much. Naturally, I went on to profiling and trying to figure
out how to improve the scaling capabilities, and one of the first things to
come across is using several threads (duh). Pretty basic stuff, so lets add and
import <code>Control.Parallel</code>, instruct the <span class="caps">RTS</span> to use a number of threads that
suits the <span class="caps">CPU</span> in use and everything should be fine.&nbsp;Right?</p>
<p>This is the new&nbsp;code:</p>
<div class="codehilite"><pre><span class="nf">runServer</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runServer</span> <span class="n">channels</span> <span class="ow">=</span> <span class="n">scotty</span> <span class="mi">3000</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">get</span> <span class="s">&quot;/&quot;</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">videos</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">sort</span> <span class="o">.</span> <span class="n">concatMaybe</span><span class="p">)</span> <span class="o">.</span> <span class="n">liftIO</span> <span class="o">.</span> <span class="n">sequence</span> <span class="o">$</span>
                <span class="n">parMap</span> <span class="n">rpar</span> <span class="n">scrapeChannel</span> <span class="n">channels</span>
    <span class="n">html</span> <span class="o">.</span> <span class="n">renderVideos</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">50</span> <span class="n">videos</span>
  <span class="c1">-- ... and more routes</span>
</pre></div>


<p>This looks neat and one might think it does what we want it to do. But looking
at the actual performance when using 15 channels, this code is only about 20%
faster, even when using 8 or more threads on a <span class="caps">CPU</span> with more than enough cores.
Time for some more in depth analysis. The first thing I decided to look at was
good old top. YouTube is not too slow in terms of respond times, so with a
couple of threads one could assume we get to start scraping the page fairly
early on, which results in increased <span class="caps">CPU</span> usage. But looking at top while
refreshing the page revealed that the <span class="caps">CPU</span> was idling for a good 10 seconds
before starting to scrape at all. Scraping was then run concurrently for the
collected pages, so all cores were used and the actual scraping only took a&nbsp;second.</p>
<p>A look at Wireshark confirmed the problem. Wireshark recorded a new request
to YouTube every second before scraping started. I looked around a bit in
<a href="https://hackage.haskell.org/package/scalpel">Scalpel</a>, the scraping library I
used and <a href="https://hackage.haskell.org/package/curl">the curl bindings</a> that
were used for the actual requests, but nothing indicated any problems with
making multiple requests at the same&nbsp;time.</p>
<p>So, now for the big reveal. For those who do not know, Haskell&#8217;s <code>Parallel</code>
only works for pure parts of code, so no <span class="caps">IO</span>, which hinders you from creating
things like race conditions, deadlocks and other really bad stuff. That is a
good thing. So, if you want to do concurrent (or parallel) I/O, you need to use
<code>Concurrent</code>, which brings internal threads, thread communication tools and
this kind of stuff. Now, this is all pretty dangerous territory in that with
these tools, we can create the bad things mentioned above, which we do not want
to risk, at least not if there are better alternatives. And as it turns out,
there are. Use <a href="https://hackage.haskell.org/package/async">async</a>. Async is
essentially a wrapper around all the evil stuff that makes it harder to shoot
yourself in the foot. For us, there is this neat function called
<code>mapConcurrently</code>, which does exactly what we want. Do a <code>map</code>, do it
concurrently, and do it with <code>IO</code>. So this is what we&nbsp;get:</p>
<div class="codehilite"><pre><span class="nf">runServer</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runServer</span> <span class="n">channels</span> <span class="ow">=</span> <span class="n">scotty</span> <span class="mi">3000</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">get</span> <span class="s">&quot;/&quot;</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">videos</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">sort</span> <span class="o">.</span> <span class="n">concatMaybe</span><span class="p">)</span> <span class="o">.</span> <span class="n">liftIO</span> <span class="o">$</span>
                <span class="n">mapConcurrently</span> <span class="n">scrapeChannel</span> <span class="n">channels</span>
    <span class="n">html</span> <span class="o">.</span> <span class="n">renderVideos</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">50</span> <span class="n">videos</span>
  <span class="c1">-- ... and more routes</span>
</pre></div>


<p>And it does exactly what we want, it starts scraping as soon as the first
request has returned a page for use, which reduces the runtime by more than&nbsp;half.</p>
    </div><!-- /.entry-content -->
  </article>
</section>
</body>
</html>
